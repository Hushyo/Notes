#  界面

三个页面：主页绘图APP    APP代表工具箱

主页里面的布局选择默认就是打开的界面

当前文件夹 绝对路径在上面显示
当前文件夹可以修改

命令行窗口就是输入代码的
工作区用来保存历史变量
右侧工作区头部可以添加属性

各窗口可以拖动，窗口右上角倒三角可以恢复默认界面

# 2

## 2.1认识

**初识**

命令行输入 x^y 回车如果不设置变量接收结果的话
工作区就会出现默认变量ans 接收这个值 ans其实是answer的缩写
ans的值是最后一个未赋值的值，而不是出现多个ans，ans会不断被覆盖更新

如果把matlab关掉了，重启时想看原来写的命令

方法1：**选择布局->历史记录->停靠  然后复制出来粘贴**
方法2：**按住右侧小键盘的箭头上或下获得之前的命令**

但是一直这样找很麻烦，所以可以把代码保存成一个文件：方法3
也就是脚本功能，代码一般写在名为脚本的文件里面

## 2.2脚本

**创建脚本**
点击主页下面的新建->脚本  或者按 快捷键 ctrl+n

把命令粘贴进来，也可以在编辑器里面写
写完 ctrl+s 或者点击 保存
可以改成记事本，方便查看代码
注意不能中文命名

再次打开matlab后，上一次的脚本还在，我们可以点击编辑器直接运行
但是它可能会提示我们当前文件夹找不到该脚本文件，所以我们需要修改啊当前文件夹为脚本文件所在的文件夹

**清工作区可以删除所有变量**，
**可以选脚本的部分代码执行**（右键选项第1个）
我们在**命令行里写上脚本的名称也可以执行脚本里的所有代码**
写脚本的名称就行，不用写后缀，如果提示找不到就更改当前文件夹


视图栏目中数据提示可以实现鼠标悬浮提示数据的效果

## 2.3实时脚本

**实时脚本**
后缀是.mlx
**普通脚本里面只写代码，而实时脚本是一个可交互的文档**(类似jupyter)
实时脚本里面可以写文字，图片甚至更多的，也可以写代码
代码运行的结果**可以直接在脚本里输出出来**

编写时 **ctrl+e** 可以**切换代码模式和文本模式**，也可以选中后ctrl+e  
（实测alt+enter也行） 
写完代码后点击运行，结果有两种显示方式，一个是右侧显示，一个是跟jupyter一样在代码行下面显示结果

![image-20240826225830417](C:/Users/13480/AppData/Roaming/Typora/typora-user-images/image-20240826225830417.png)

不想点击运行？有没有快捷键？有，ctrl+enter

实时编辑器里面也可以插入方程



脚本能不能转换为实时脚本？可以，右键脚本，选择“以实时脚本方式打开”

### 小节

插入->分节符创建新区域，用于区分不同小节

快捷键是 ctrl+alt+enter![image-20240826230254344](C:/Users/13480/AppData/Roaming/Typora/typora-user-images/image-20240826230254344.png)

按住ctrl加小键盘上下可以在不同小节内切换

实时编辑器里面的功能：运行节 可以只运行小节里面的代码，快捷是ctrl+enter
如果点右边的运行，那么会运行所有代码  F5
节内内容删完，节就自动消失了

还有一个控件功能，很好用



实时脚本还可以导出成各种格式的文档



## 2.4文件管理

**matlab文件管理**

想执行文件时，matlab在当前文件夹里寻找，找不到就在当主页里设置路径里接着找，找不到就报错

切换当前文件夹可以直接右键脚本切换
也可以把脚本路径改成搜索路径(不推荐)，如果自己代码跟matlab文件重名的话，matlab调用命令可能用自己的代码，而不是应该调用的代码
自己探索



![image-20240826232618246](C:/Users/13480/AppData/Roaming/Typora/typora-user-images/image-20240826232618246.png)
在当前文件夹里找不到aaa脚本，在搜索路径里也找不到aaa脚本
在工作区也没找到aaa变量，那就报错
aaa在不同的环境下对应的角色不一样，在工作区里找，找的就是变量
如果同时存在脚本aaa和变量aaa，那么matlab会使用变量aaa

工作区里的数据也可以保存到本地，格式为.mat，是matlab的数据文件



## 2.5帮助文件

**帮助文件**
matlab功能很多，全记住不现实
查阅matlab帮助文件

1. 帮助文件在官网帮助中心里
   比如查阅sum怎么用，点击去有很多说明以及示例
2. doc文件
   在命令行窗口输入 doc 空格 命令 如 doc sum
   弹出来帮助界面（可能未汉化）
3. help
   同样是 help 空格 命令
4. edit
   edit 命令
   弹出对应命令的脚本文件（其实是调用了）自己看
   每一句都有%开头，百分号开头的语句代表注释！
   注释不会影响运行结果
   在命令里也可以写%开头的命令，不会运行，**注释哦注释**
   脚本文件注释快捷键 ctrl+r 和 ctrl+t

## 2.6变量

### **变量**

a=3
变量名 a
变量保存的数据 3
用等号=赋值 两边可以加空格

matlab不要求提前声明变量类型
根据数据自动识别变量类型，好像是python

### **规范**

变量必须字母开头，后面仅可以是字母数字下划线  n! 无效
matlab大小写敏感， A a 属于不同变量
变量名不能超过63个字符
不能与关键字同名比如 end，if
想知道哪些是关键字？输入 iskeyword 命令 一共有20个关键字

### **Matlab预定义的特殊变量**

这些虽然是特殊变量，但是我们可以用同名变量
比如 命令输入 pi=3 那么运行后变量pi结果就是3
大致意思就是这些变量有默认值，我们可以更改，如果不想用更改后的值，只需要在工作区把这个变量删掉，那么这个变量就恢复默认值

ans 用于保存结果的变量名
pi 圆周率Π 显示3.1416  命令行输入 pi 运行结果是后边 ans变量等于3.1416
inf 和 -inf 正负无穷大 （infinity） -1/0 = -inf
NaN 不定值，表示不确定的值或者缺失值 比如0/0 或 0\*inf
i j 复数中的虚数单位 **i和j都代表虚数单位** 3+4i 和 3+4j是一样的！
对于虚数单位i或者j 如果我们给i j 单独赋值比如 i=3
那么 3+4i结果是什么呢？还是虚数，而不是 3+4*3=15 自动将它识别为虚数
原因一 没加\*不算乘运算，原因二 把i识别出来虚数单位

eps浮点相对精度
命令行输入eps显示2.2204e-16
科学计数法的表示,e+数字等于乘上10的多少次方

### 显示格式

1.使用format临时更改数值显示
`format(style)` 将输出显示格式更改为 `style` 指定的格式。例如，`format("shortG")` 以总共 5 位的紧凑形式显示数值。数值格式仅影响数字显示在的显示方式，而不是 MATLAB® 计算或保存它们的方式。

当您按名称指定样式时，可以使用不带括号或引号的*命令形式*

```matlab
format shortG
```

以及
fmt= format(style)将当前显示格式存储在 `fmt` 中，然后将显示格式更改为指定的样式
当请求输出时或传递变量作为输入时，无法使用命令形式。请将输入括在括号中，并将样式名称包含在引号中。

```
fmt = format("shortG");
format(fmt)
```

![image-20240829001253663](C:/Users/13480/AppData/Roaming/Typora/typora-user-images/image-20240829001253663.png)

也可以在主页->布局右边的预设项->命令行窗口内设置数值格式
重启matlab后，显示方式是预设项内的格式


clear清除工作区  也可以指定变量清除  clear变量名
clc清楚命令区
把这两个命令写在脚本开头，可以在执行前清除两个部分的内容
脚本里的命令如果加分号的话，执行时命令行窗口只有这个命令，不会显示执行的结果
这就是加分号与不加分号的区别
还有另一个作用，两行代码写在同一行用来隔开，不然命令识别错误，报错

## 2.7运算函数

**常见的数学运算函数**
加减乘除平方省略   9^1/2 = 4.5  9^(1/2)=3 注意运算顺序
加括号改变运算顺序
**abs( ) 绝对值**，还可以计算复数的模长
abs(1.5)  % 1.5；abs(3+4i)   % 5

**floor( )取小于该数的整数**
floor(1.2)=floor(1.9)=1
floor(-1.1)=floor(-1.9)=-2

**ceil( )取大于该数的整数**
floor(1.2)=floor(1.9)=2
floor(-1.1)=floor(-1.9)=-1

**fix( )取整数部分**
fix(1.1)=fix(1.9)=1
fix(-1.1)=fix(-1.9)=-1

**round( )真正意义上的四舍五入**
如果为入的那一位是5，则朝着偏离0的方向入
round(X,N)四舍五入到N位数
N>0舍入到小数点右边N位数  round(3.14159, 2)  % 3.14
N<0舍入到小数点左边N位数 round(12345.6, -1)   % 12350  5入

**mod(a,b) 取模**，a mod b

**sqrt( )开方** 如果开不尽，根据format显示结果，但是计算时按真实值算
如果输入的数是复数，则返回复数结果

**exp( )计算以e为底的指数**
exp(2)=e^2
e不是特殊变量，没有默认值 e^2报错
想知道自然常数e的二次方，要输入exp(2)

**log()计算以e为底的对数**
log(exp(2))=2
log2( )和log10( )计算以2为底或以10为底的对数
log2(4)=2；log10(100)=2
那么怎么计算以任意常数a为底的对数？比如log3(9)？直接这么写报错
需要用到换底公式，log3(9)写成 log(9)/log(3) 或是 log2(9)/log2(3)
对数只有  log  log2 log10  其他的都要用换底公式

**三角学对应函数**
sin cos tan
输入的角度应该是弧度单位，即多少多少派
sin(pi/3)  注意这里的pi应该是默认值，而不是我们手动赋的值
即使输入的值不含pi，他也会按照弧度制计算
asin(0.5)=0.5236 sin(0.5236)=0.5

如果想用角度单位 即输入多少多少度 应该用
sind cosd tand
sind(30) sin30度 = 0.5000

asin acos atan
用来计算反正弦、余弦、正切函数

返回结果为弧度制，后面省略了单位pi

这些函数名不要作为变量名给他们赋值哦！如果赋值了，那么会出现以下错误

% sin(pi/6)  % 报错：下标索引必须为正整数类型或逻辑类型
% 解决方法：将变量sin从工作区删除 删了就正常了
% sin(2*pi) 结果不是0 怎么解释？是一个非常接近于0的数，但是为什么不等于0？
% 浮点数的计算存在误差

# 3矩阵

## 3.1基础



**向量**
由 n 个数构成的数表 **[a~1~,a~2~,···a~n~]**或者其转置，称为 n维行向量或者n维列向量
横着叫行，竖着叫列
向量是矩阵的特例，行向量是行数为1的矩阵，列向量是列数为1的矩阵

**向量的模**
对向量中每个数进行平方并求和，对和开平方，即为向量的模，记为**|α|**

向量可以视为矩阵的一个特例，如果一个矩阵的行列都是1，那么他就是一个标量
又称为常数，常量
在matlab里，向量可以被称为一维数组，数组就是同类型的若干元素嘛
矩阵可以被称为二维数组，一维数组可以视为二维数组的一个特例
我们还可以定义多维数组，但是绝大多数情况下用不到，想用看帮助文档

下面将矩阵和数组视为同一个概念

## 3.2向量

### 3.2.1创建向量

1. **直接输入**
   向量元素需要用中括号括起来[ ] 
   元素之间可以用 空格 逗号 分割创建行向量
   							分号 回车分割创建列向量

2. **冒号法** 最常用

   A：step : B 创建行向量
   A起始值，Step 步长， B终止值(不一定最终停在B)，例如 1:2:4结果是1,3
   如果最终超过了B，那么B就不算在内
   步长可以是负的

   如果step等于1，可以直接写为A:B

   如果向量设置不合理，则变为空向量: 1x0 double 行向量
   0:0:1，5:2:1，都返回 1x0 double 行向量 double代表双精度浮点型
   直接写一个空括号会返回一个空向量 两种方式创建的空向量等价

3. **函数创建法**
   步长由matlab自动计算
   绘制图像时，用函数比较精准，比起冒号法，
   向量的最后一个元素一定是b   冒号法不一定是b
   比如从0到2pi，自己设置步长，大概率会把最后的2pi丢掉

   1. **linspace** 行向量
      两种用法，区别在于是否给定第三个输入参数n
      如果不指定n，那么默认n=100
      linspace(a,b) 从a到b分成n=100元素的行向量 
      linspace(a,b,n)从a到b分成n个元素的行向量
      如果a>b，那么步长是负的
      如果a=b，那么向量里所有数都是a，步长为0 了属于是

      ```
      linspace(1,10,10)
      1,2,3,4,5,6,7,8,9,10
      ```

   2. **logspace** 不是列向量
      同样是行向量，只不过结果是等比数列行向量
      logspace(a,b)第一个元素是 **10^a^**，最后一个是 10^b^
      同样有第三个参数n，这里n默认是50
      这个q由matlab自己算

      ```
      logspace(log10(2),log10(1024),10)
      2，4，8，16····1024
      想以上显示要设置 format short g
      ```

### 3.2.2向量引用

如何引用向量元素，即调用向量某个索引的值
调用单个或者多个
matlab中可以调用 **length**函数或者 **numel**函数计算向量中元素个数 
length(向量)  空向量元素个数是0哦

**matlab中索引值从1开始！！！**

**调用单个元素**
**a(index)**真的很简单
如果索引大于元素个数，报错
如果索引是负数，0，小数也会报错
索引只能是正整数或者逻辑值

**调用多个元素**
如果把index设置成向量的话，便可以取对应索引的值
比如**a(1:2:9)**取奇数位置的数   **a([1,3,5,7,9])**
只要a里面是个向量就行，可以是结果为向量的表达式

**end索引**
如果我们不知道a中有多少元素，也不想用numel或者length计算元素个数
那么可以利用end代替向量的最后一个索引
比如取奇数位置 a(1:2:end)，从第五个取到倒数第三个 a(5:end-2)
但是单独写一个 ind=end-2是不行的，单独拿出来的end没有任何意义

a(1) 当作数组提取第一个
a(1,2)  当作矩阵提取一行二列的元素
a(2,3) 当作矩阵提取的二行三列的元素
a([1,2]) 当数组取 1,2 位置的元素
灵活一些



### 3.2.3修改删除

**修改向量**
调用后等号赋值
a(1)=4 把第一个元素变成4
a([1,3])=[10,20] 把第一个改成10，把第三个改成20
等号赋值！对应位置赋值！
左右两侧元素个数要相同，不然无法执行  除非👇

右边为常数，只有一个数，那么把左边对应位置全部改成该常数

如果向量a只有五个元素，a(8)肯定报错,
但是a(8)=10对第八个赋值，不会报错，而且还会把8之前没有值的位置用0填充
同样，a(2,8)=10也不会报错，它会把a扩充成这个大小，然后给这个位置赋值，其余填0
上述两者改变向量大小的赋值方式，不能在本不存在的位置赋空值，如果超量赋空值，那么会报错，超量赋值会先扩容，再赋值，这样不会报错

**删除向量**
a(1)=[] 删除第一个
a(1:end)=[]删完

## 3.3矩阵

### 基础

**矩阵**
m行n列数表称为mxn阶矩阵，记为**A=(a~i~~j~)~mxn~**
 当m=n时，称为n阶方阵或者n阶矩阵

**同型矩阵**
矩阵A B行列数都相同，称为同型矩阵
只有两个矩阵同型才能相加减

**转置矩阵**
沿对角线翻转

**单位矩阵**
用E 或者 I 表示单位矩阵
单位矩阵主对角线为1 其余位置都是0

**矩阵相乘**
矩阵相乘必须保证左边矩阵的列数等于右边矩阵的行数
**A~ij~*B~jk~=C~ik~**
结果的行列为 左矩阵的行，右矩阵的列

**逆矩阵**
A矩阵是n阶方阵，如果存在n阶矩阵B 使得AB=E或BA=E
那么称矩阵A可逆，B是矩阵A的逆矩阵，**B=A^-1^**
必须是方阵，只有方阵才可能存在逆矩阵

**特征值和特征向量**
n阶方阵A满足条件 存在数 **λ**（λ可为复数）和非零n维列向量x
使得 Ax=λx成立，则称 λ是方阵A的特征值，x为方阵A的特征向量

**特征向量不唯一**， kx也是A对应于特征值λ的特征向量



### 3.3.1创建

1. **直接输入法**
   同样是以[ ]作为标识符号，矩阵所有元素都必须再中括号内，矩阵同行元素之间用空格或逗号分割，不同行用分号或者回车分割

   ```matlab
   a=[1,2,3;4,5,6]
   a=[1 2 3
      4 5 6]
   a=[1:3;4:6]
   a=[[1,2,3];[4,5,6]]
   ```

2. **函数创建法**
   第一组函数 **zeros,ones,eye**
   分别用来创建全为0，1的矩阵和单位矩阵E 用法相同 以zeros为例 
   zeros(n) 创建n阶全为0的方阵
   zeros(m,n) m行n列的全0方阵

   ```matlab
   zeros(3)
   ans = 3×3    
        0     0     0
        0     0     0
        0     0     0
   zeros(2,3)
   ans = 2×3    
        0     0     0
        0     0     0
   e=eye(4,3)
   e = 4×3    %看一看主对角线是什么，矩阵并非方阵市，记住主对角线是什么
        1     0     0
        0     1     0
        0     0     1
        0     0     0
   one=ones(3)
   one = 3×3    
        1     1     1
        1     1     1
        1     1     1
   ```

   第二组函数 **rand randi randn** 函数
   分别用来创建 **均匀分布的随机数，均匀分布的随机整数，正态分布的随机数**
   随机数可能是小数哦，如果不用randi的话

   **rand函数**
   用来创建01之间均匀分布的随机数，常用**rand(n),rand(m,n)**
   创建对应行列的矩阵，矩阵每个元素都是01之间的随机数
   每次运行的值都不同

   **randi函数**
   用来创建均匀分布的随机整数，这次的范围不再限制再01
   我们可以自己设置范围 **randi([min,max],m,n)**
   给定范围，可以用向量设置范围，后面的m,n代表矩阵的形状
   想生成方阵？只写n或m就行

   这里 [min,max] 是直接输入创建向量，只能写两个数，一个最大数一个最小数
   如果min是1的话，可以不写min,只写max就可以了

   ```
   randi([1,10],2,3)
   randi(10,2,3)
   ```

   **randn函数**
   创建符合标准正态分布的随机数，用法类似rand
   randn(n)
   randn(m,n)
   创建对应形状的矩阵，不过矩阵内元素分布符合标准正态分布
   标准正态分布N(0,1)： 均值为0，标准差为1

   ```
   randn(4)
   ans = 4×4    
         0.60293      -1.4207      -1.5045      0.76285
         -1.5163      0.66937      0.43314      -1.1821
       -0.068349      0.68324      0.80826      0.58385
         0.78239     -0.88214      0.57894     -0.58001
   ```

   第三组函数 **diag和blkdiag**
   **diag函数**
   用于创建对角矩阵或者获取矩阵的对角元素
   如果**第一个参数是向量**，则标识创建对角矩阵
   **diag(v,k)**
   将向量v的元素放置在第k条对角线上，其他元素为0
   k默认是0，可以不写；

   ```
   diag(1:3)
   ans = 3×3    
        1     0     0
        0     2     0
        0     0     3
   ```

   k>0，位于主对角线上方；

   ```
   diag(1:3,1)
   ans = 4×4    
        0     1     0     0
        0     0     2     0
        0     0     0     3
        0     0     0     0
   ```

   k<0，位于主对角线下方

   ```
   diag(1:3,-1)
   ans = 4×4    
        0     0     0     0
        1     0     0     0
        0     2     0     0
        0     0     3     0
   ```

   创建的矩阵形状视情况而定
   规律好像是 length(v)+abs(k) 阶方阵？

   如果**第一个参数是矩阵**，那么代表获取矩阵对角线上的元素
   diag(A,k)获取矩阵A第K条对角线上的元素构成的**列向量**

   ```
   A=diag(1:3,-1)
   A = 4×4    
        0     0     0     0
        1     0     0     0
        0     2     0     0
        0     0     3     0
   diag(A,-1)
   ans = 3×1    
        1
        2
        3
   ```

   **blkdiag函数**  block diagonal
   分块对角矩阵
   主对角线上的元素 是矩阵 例👇

   ```
        A1     0     0     0
        1      A2    0     0
        0      2     A3    0
        0      0     3     A4
   A1A2A3A4可以是大小不同的矩阵
   ```

   ```matlab
   A1 = 2×3    
        1     2     3
        4     5     6
   A2 = 2×2    
        2     4
        3     6
   A3 = 3×2    
        1     2
        3     4
        5     6
   blkdiag(A1,A2,A3)
   ans = 7×7    
        1     2     3     0     0     0     0
        4     5     6     0     0     0     0
        0     0     0     2     4     0     0
        0     0     0     3     6     0     0
        0     0     0     0     0     1     2
        0     0     0     0     0     3     4
        0     0     0     0     0     5     6
   ```

3. **本地导入数据**
   matlab可以读取本地的文件，常见格式如下
   .txt，.dat，.csv
   .xls，.xlsb···
   如何导入呢？
   最傻瓜的方法 复制粘贴直接输入
   使用工具箱  主页->导入数据 功能 以后补充

### 3.3.2引用

**单个元素**
**a(row_index,column_index)**
同样，超范围报错，但是超范围赋值会扩容后赋值，自动填0

```
A = 4×4    
     3     8     6     4
     3     9     8     9
     2     9    10     4
     6     8     6     4
```

```
A(3,2) %2
A(5,5)=10
A = 5×5    
     7     3     6     6     0
    10     8     9     9     0
    10     2    10    10     0
     2     2     2     9     0
     0     0     0     0    10
```


**多个元素**
行索引或者列索引是向量，提取对应下标的元素

```
A(1:end,2:3)
ans = 4×2    
     3     3
     3    10
     4     8
     8     3
A(1:2:end,1:2:end) 奇数行列的数
ans = 2×2    
    3     6
    2     10
```

如果我们需要取矩阵的某一行或某一列，就可以使用
A(i,1:end)  A(1:end,j)
如果是 1:end,可以直接简写为 :
A(:,n)表示取所有行第n个元素,即取第n列元素

```
A=randi(10,10)
A(:,[2,5])
取第二第五列的元素
```

**矩阵大小**
numel length计算向量元素个数，矩阵大小用size函数计算
size(A)，返回行向量，每个元素对应每个维度的长度
A是3x4矩阵,size(A)=[3,4]

```
A=randi(10,4,5)
size(A)
ans = 1×2    
     4     5
```

size(A,dim) 返回指定维度的长度 dim=1表示求行，dim=2表示求列

```
size(A,1) %4
size(A,2) %5
A=1:5 是个向量，也算是特殊的矩阵
size(A) % 1 5  一行五列
```


length和numel也可以用在矩阵上
length返回值是行列较大值，而numel返回元素个数
向量也是矩阵，返回较大值不就是向量的列数，也就是向量的元素个数吗？ 
numel才是实打实求元素个数的函数！



**线性索引**
前面我们其实是在对矩阵的双下标进行索引，那么我们能不能使用单个下标对矩阵索引？
看着是二维的，但是在内存中是线性存储的，是每一列按顺序存

```
A = 3×5    
     6     3    10     7     6
     6     4     7     6     8
     9     2     5     7     6
存的时候是 6 6 9 3 4 2 10 7 5 7 6 7 6 8 6这样一列一列存
```

第三列第一个线性索引下标就是7
如果使用线性索引A(:)那么结果是按线性排列的一个列向量
将A中所有元素按照线性索引顺序重构成一个列向量

**行列索引和线性索引转换**
**sub2ind函数和ind2sub函数**
sub2ind 意为 将下标sub转换为 ind线性索引 2就是to的意思，发音相同

**sub2ind**
**ind=sub2ind(sz,row,col)**
针对大小为sz的矩阵,sz代表矩阵大小，返回由row，col位置的线性索引

```
ind=sub2ind([3,5],1,3)
对3x5的矩阵，第一行第三列位置的线性索引是多少
结果ind=7
```

**ind2sub**
**[row,col]=ind2sub(sz,ind)**
返回值为行列的向量，由一个向量接收
根据给出的矩阵大小和线性索引值推断出在该矩阵中的行列值

```
[row,col]=ind2sub([3,5],7)
row = 1
col = 3
```

两个函数功能刚好相反

### 3.3.3修改删除

仍然是等号赋值

**单个赋值**
A(row,col)=10
**多个赋值**
A(3,:)=100 第三行全部变成100，右边是常数就全变
A([1,3],[2,3])=[8,88;888,8888]
取一三行二三列的元素对应变成右边的，两边大小要匹配哦

```
A = 3×5    
           6           8          88           1          10
           1           7           5           9           7
           2         888        8888           6           6
```



当然也可以用线性索引更改
比如更改奇数位置 A(1:2:end)=0

```
A = 3×5    
     0     8     0     9     0
     9     0     6     0     6
     0   888     0     5     0
```

A([3,5,6])=666

```
A = 3×5    
     0     8     0    10     0
     6   666     8     0     6
   666   666     0     6     0
```

如果索引超过了矩阵大小，那么矩阵会自动变大！

对于矩阵范围外插入值，我们还可以插入矩阵
A(4:5,6:7)=10 在四五行六七列插入10

```
A = 5×7    
     9     1     9     4    10     0     0
     1     5     2     5     4     0     0
     3     1     1     2     3     0     0
     0     0     0     0     0    10    10
     0     0     0     0     0    10    10
```

不能利用线性索引变大，大概是，正确性与原因未知

**删除元素**
只需要把右边改成 [ ] 
但是在矩阵里，我们只能删除整行和整列，因为单独删除元素矩阵不再是矩形，报错
删除是把那个元素直接给删掉，位置不会空着，是被填充

这个也叫空赋值
空赋值只能具有一个非冒号索引 举例 A(2,2)=[ ] 两个2，两个非冒号索引！报错



线性索引删除
删除后matlab会将矩阵剩下的元素按照线性索引的顺序放入到一个向量中
使用线性索引可以删除任意位置的元素，以为返回值是一个向量，不局限矩阵的形状
删除后，矩阵不存在了，变成一个行向量



### 3.3.4拼接重复

矩阵拼接变成大矩阵，分为水平拼接和垂直拼接
matlab中使用**[A,B]**或**[A B]**横向拼接;使用**[A;B] [A 回车B] 垂直拼接**
注意矩阵是否符合拼接条件

使用函数
**horzcat(A,B)**横向拼接 horizontal 水平的
**vertcat(A,B)**垂直拼接 vertical 垂直的

两个函数都源于cat函数👇

**cat(dim,A,B)** 沿着维度dim方向将矩阵B拼接到A的尾部
dim=1表示行，即B从A的最后一行拼接，也就是垂直
dim=2表示列，B从A的最后一列开始拼，也就是水平

```
A = 3×3    
    69    37    78
    60    21    21
    79     9    39
B = 3×3    
    56    49    11
    23    16    30
    65    79    24
[A,B]  horzcat(A,B) cat(2,A,B)
ans = 3×6    
    69    37    78    56    49    11
    60    21    21    23    16    30
    79     9    39    65    79    24
[A;B]  vertcat(A,B) cat(1,A,B)
ans = 6×3    
    69    37    78
    60    21    21
    79     9    39
    56    49    11
    23    16    30
    65    79    24
```

拼接时维度不一致会报错
大于两个矩阵进行拼接也可以用上述方法 
**horzcat(A,B,C,D) cat(2,A,B,C,D)  [A,B,C,D]**

**矩阵重复堆叠**
想把A矩阵行方向上变成n个，列方向变成m个
调用 repmat函数 rep表示重复repeat  mat表示矩阵 matrix矩阵

repmat(矩阵，row,col) 在行方向上重复row次，列方向上重复col次
如果行列重复次数相等，可以用一个数代替 repmat(A,n)

```
A = 2×3    
     1     2     3
     2     3     4
repmat(A,3,2)
ans = 6×6    
     1     2     3     1     2     3
     2     3     4     2     3     4
     1     2     3     1     2     3
     2     3     4     2     3     4
     1     2     3     1     2     3
     2     3     4     2     3     4
```



**元素重复**
**repelem函数**
**重复向量v中的元素**
**repelem(v,n)** 
n是整数时，**把v中的每一个元素都重复n次**
n是向量时，长度必须跟v相同，意思为**把v(i)重复n(i)次**

先重复一个元素，再重复下一个元素，而不是一整个一整个重复
一整个重复那就是 repmat了，当作矩阵重复列了，注意区别

```
a=[1,2,3]
repelem(a,3)
ans = 1×9    
     1     1     1     2     2     2     3     3     3
repmat(a,1,3)
ans = 1×9    
     1     2     3     1     2     3     1     2     3
```

**重复矩阵A中的元素**

**repelem(A,m,n)**

m,n是常速时
将每一个元素行方向重复m次，列方向重复n次

```
A = 2×3    
     1     2     3
     4     5     6
repelem(A,2,3)
ans = 4×9    
     1     1     1     2     2     2     3     3     3
     1     1     1     2     2     2     3     3     3
     4     4     4     5     5     5     6     6     6
     4     4     4     5     5     5     6     6     6
```

m，n是向量时 m必须与A的行数相同，n必须与A的列数相同
按下标顺序重复对应次数
repelem(A,[2,3],[3,4,3])
沿着行方向从上往下看 第一行重复两次，第二行重复三次
沿着列方向从左往右看 第一列重复三次，第二列重复四次，第三列重复三次

```
repelem(A,[2,3],[3,4,3])
ans = 5×10    
     1     1     1     2     2     2     2     3     3     3
     1     1     1     2     2     2     2     3     3     3
     4     4     4     5     5     5     5     6     6     6
     4     4     4     5     5     5     5     6     6     6
     4     4     4     5     5     5     5     6     6     6
```

### 3.3.5重构

**reshape**函数
更改矩阵的形状

**sort**函数
对向量或者矩阵排序

**sortrows**函数
基于矩阵的某一列对矩阵排序，同一行的元素不会变

**flip/fliplr/flipud** 
矩阵反转 lr左右 ud上下

**rot90**
矩阵逆时针旋转90度的倍数



#### **reshape**

改变矩阵形状，前提是能改哈
**reshape(A,m,n)** 或者 **reshape(A,[m,n])**

该函数按照矩阵的线性索引重新组织元素顺序，先取第一列放在第一行，···
所以按选型索引取值是完全相同的  A(:) = B(:)

如果我们只给出行数或者列数，那么会自动计算剩下维度的个数
reshape(A,3,[ ]) 自动变成三行，多少列它自己算
reshape(A,[ ],4) 四列，多少行他自己算

可以用来将行向量转换为列向量

#### **sort**

排序有两种，从小到大即升序，从大到小降序  默认升序
sort向量  对行列向量都有效
sort(v) 将v中元素从小到大升序排列
sort(v,'descend') 降序

sort只有一个返回值，也就是排序后的向量，但是也可以让它返回两个变量
[sort_v,ind]=sort(v)
左边用两个变量接收时，它便返回两个
第一个是排序后的结果，第二个代表着元素在原向量中的位置

```
v = 1×7    
     1     3     2     4     7     8     5
[av,ind]=sort(v)
av   
     1     2     3     4     5     7     8
ind    
     1     3     2     4     7     5     6
```

实际运用：84分的同学排第几？看84对应位置在ind中的数值
但是存在相同数值时，结果有两种情况
1.普通排名 如果两个都并列第一 那么排名可能是  1，1，3，4，5，没有2
2.中国式排名 结果是 1,1,2,3,4 中国式排名中,并列排名不占用名次
当然这是实际应用需要注意的地方,有另外一个函数解决这个问题
ind结果不会把并列的下标设置相同,先出现的排前面



**对矩阵排序**
**sort(A,dim)**
dim=1,从上到下,沿着行方向对矩阵的每一列升序  
dim=2,从左到右,沿着列方向对矩阵的每一行升序

```
A = 6×6    
     5     2     6     5     2    10
    10     8     9     4     1     5
     5     9     6     6     3     3
     7     4     4     8     4     8
     2     7     3     5     7     8
     4     3     5     5    10     8
sort(A,1)
ans = 6×6    
     2     2     3     4     1     3
     4     3     4     5     2     5
     5     4     5     5     3     8
     5     7     6     5     4     8
     7     8     6     6     7     8
    10     9     9     8    10    10
```

可以看到,按行方向排列时,是逐列处理的,最后每一列的数据都是升序的
这样打乱了行中的数据
比如第一行本来是 5 2 6 5 2 10,但是排序后 5那一行变成了 5 4 5 5 3 8
沿着列方向处理同理

我们跟向量排序一样可以接收两个返回值
[sort_A,ind]=sort(A)
ind也是一个矩阵,元素值代表着对应位置的元素在本次排序维度上,该元素在其原本所在行/列的线性索引值

```
[sort_A,ind]=sort(A,1)
ind = 6×6    
     5     1     5     2     2     3
     6     6     4     1     1     2
     1     4     6     5     3     4
     3     5     1     6     4     5
     4     2     3     3     5     6
     2     3     2     4     6     1
     这个dim=1,按行方向,即每一列单独排
第一列 5对应位置是2,2在原本列中排第五,所以是5
```

#### **sortrows**

基于矩阵的某一列对矩阵排序
排序后新矩阵的同一行元素不会像上面那个sort一样改变，结果会乱掉
假如有六名学生有六科成绩，想按语文排序，那么就应该用sortrows
保证这一行是同一个学生的成绩

最简单的用法
**sort_A=sortrows(A,column)** 
**column是常数**时，按照column列排序 ，默认升序
**column是向量**时，按照column里的数字
以[1,2,3]\(或者1:3)为例，先按第一列排，当第一列相同时按第二列，当第二列相同时按第三列
如果全部相同，那么按照出现顺序排

```
A = 6×6    
    94    83    82    81    83    91
    95    88   100    88    85    83
    89    88    88    85    83    97
    81   100    96    96    82    93
    84    81    97    89    98    87
    99    89    98    99    92    90
sortrows(A,[2,3])
ans = 6×6    
    84    81    97    89    98    87
    94    83    82    81    83    91
    89    88    88    85    83    97
    95    88   100    88    85    83
    99    89    98    99    92    90
    81   100    96    96    82    93
先按第二列，发现第二列种第三第四行相同，那么看这两行的第三列
显然100大，所以100那一行放下面
```

如果column是全部列，要么写1:最后一列的数字，要么省略不写column
唯独不能写**1:end**,因为这里的end没有意义，没有指向值
end 运算符必须用在数组索引表达式中 如A(1:end)

sortrows(A,[1,3],'descend') 
第一列第三列都是升序，写上descend

sortrows(A,[1,3], {'descend','ascend} ) 
这个意思是 第一列相同时，相同的几行 按照他们的 第三列 升序排列
注意用 {  } 包起来升降序关键字 大括号括起来的数组表示原包数组

注意写了原包数组时，数组里面的每一个和元素都要有 column里的元素与其对应
sortrows(A, {'descend','ascend} )  所以此时不能省略column,必须有元素与其对应
而且是一一对应，原包数组不能多，column也不能多，元素数目必须相同
**numel(column)=numel({原包数组})**
**[sort_A,ind]=sortrows(A,1:4,{'descend','ascend','descend','descend'})**

**[sort_A , ind]=sortrows(A,column)** 
同样可以返回ind，表示数字在其列中原先所处的行数
ind是一个列向量，代表该行在原先矩阵中所处行的位置

```
[sort_A,ind]=sortrows(A,[2,3],{'descend','ascend'})
sort_A = 6×6    
    81   100    96    96    82    93
    99    89    98    99    92    90
    89    88    88    85    83    97
    95    88   100    88    85    83
    94    83    82    81    83    91
    84    81    97    89    98    87
    可以看到默认情况下按照第二列大小降序排列
但是第三第四行相同，所以这两行又按照第三列进行升序排列
ind = 6×1    
     4
     6
     3
     2
     1
     5
这个ind是矩阵中行的排序结果
可以使用ind对矩阵进行行索引A(ind,:)
得到的结果就是排序后的结果
```



#### **flip/fliplr/flipud** 

flip是一个通用的翻转函数，fliplr/filpud是其特例

**flip(A)**
如果A是向量，那么flip(A)将反转向量中元素的顺序，向量的方向不变

```
A=[5,3,4,2,1]
flip(A)
ans = 1×5    
     1     2     4     3     5
```

如果A是矩阵，那么flip(A)将对矩阵进行上下翻转

```
A = 4×4    
    41    13    33    43
    25    15    12    10
    19    48    19    11
    26    49    24    16
flip(A)
ans = 4×4    
    26    49    24    16
    19    48    19    11
    25    15    12    10
    41    13    33    43
```

**flip(A,dim)**
沿着维度dim对A翻转
dim=1 表示行，flip(A,1)将沿着行方向对A进行翻转，也就是上下翻转
dim=2 表示列，flip(A,2)将沿着列方向对A进行翻转，也就是左右翻转
flip(A,1) A是向量时，结果不变，因为只有一行，怎么上下翻转都是它



#### **rot90**

对矩阵进行旋转的函数，源于rotate一词
**rotate(A,k)**
将矩阵**逆时针**翻转k*90度，k默认是1，k是负数时不就是顺时针旋转了嘛



## 3.4运算

调用函数运算，算术运算，关系运算，逻辑运算，集合运算

### 3.4.1调用函数

前面学了 abs,sin, round, log等函数，这些函数也可以用到矩阵上
用到矩阵上时代表对矩阵的每个元素都执行这个函数

```
A = 4×4    
     1    10     3     6
     3     8     5     3
     9     5    10     5
     1     6     6     7

B=exp(A)
B = 4×4    
       2.7183        22026       20.086       403.43
       20.086         2981       148.41       20.086
       8103.1       148.41        22026       148.41
       2.7183       403.43       403.43       1096.6
C=fix(B)
C = 4×4    
           2       22026          20         403
          20        2980         148          20
        8103         148       22026         148
           2         403         403        1096
D=mod(C,3)
D = 4×4    
     2     0     2     1
     2     1     1     2
     0     1     0     1
     2     1     1     1
```

exp %计算自然常数e的指数 exp(2)=e^2^

| 函数名  |              作用               |
| :-----: | :-----------------------------: |
|   sum   |              求和               |
|  prod   |             求乘积              |
| cumsum  | 计算累积和<br /> cumulative sum |
|  diff   |            计算差分             |
|  mean   |             平均数              |
| median  |             中位数              |
|  mode   |              众数               |
|   var   |              方差               |
|   std   |             标准差              |
| min,max |              最值               |

#### **sum**

用于求和
如果A是一个向量，**sum(A)**可以计算A中所有元素的和
如果A是一个矩阵，**sum(A,dim)**计算A矩阵沿着维度dim方向所有元素的和
dim=1沿着行方向计算每一列的和，返回行向量，各个元素代表各自列的元素和
dim=2沿着列方向计算每一行的和，返回列向量，各个元素代表各自行的和

```
D = 4×4    
     2     0     2     1
     2     1     1     2
     0     1     0     1
     2     1     1     1
sum(D,1)
ans = 1×4    
     6     3     4     5
sum(D,2)
ans = 4×1    
     5
     6
     2
     5
```

![image-20240831205935030](C:/Users/13480/AppData/Roaming/Typora/typora-user-images/image-20240831205935030.png)

![image-20240831205940862](C:/Users/13480/AppData/Roaming/Typora/typora-user-images/image-20240831205940862.png)

当 `dim` 大于 `ndims(A)` 或者 `size(A,dim)` 为 `1` 时，`sum` 返回 `A`。

如何计算矩阵中所有元素的和？用两次sum
比如第一次sum返回一个行向量，然后第二次sum计算该行向量的和
也可以使用A(:)按照线性索引把矩阵拼接成列向量，再用sum求和

```
sum(sum(A))
sum(A(:))
从2018b版本开始也可以用sum(A,'all')使用
```

如果矩阵中存在NaN值时，NaN指不确定或者缺失值，这种情况下求和结果也是NaN
我们可以在求和函数sum里假如 omitnan参数使得计算时忽略NaN  sum(A,'omitnan')
nan和NaN这两个一样

#### prod

product 乘积

和sum用法相同，只不过是用来算乘积的

```
V=1:5
prod(V)
ans=120
```

同样有NaN结果是NaN，加上omitnan忽略NaN

矩阵也是 prod(A,dim)按维度乘积

#### cumsum

累积和
**cumsum(A)**
A是向量，可以计算A的累加值

```
V=1:5
cumsum(V)
ans = 1×5    
     1     3     6    10    15
第三个，前三项相加等于6 以此类推
```

**cumsum(A,dim)**
A是矩阵，可以沿维度计算累积和  dim默认是1

```
V = 3×4    
     1     5     7     6
     8    10     9     2
     6     7     9     3
cumsum(V,1) 
ans = 3×4    
     1     5     7     6
     9    15    16     8
    15    22    25    11
cumsum(V,2)
ans = 3×4    
     1     6    13    19
     8    18    27    29
     6    13    22    25
```

同样假如 omitnan 来忽略NaN

#### diff

计算差分，差分运算就是用原始序列中的下一个值减去上一个值得到新的序列
这个过程就是一阶差分，在一阶差分基础上在进行一次一阶差分得到二阶差分



**diff(A,n)** A是向量，n代表n阶差分，默认是1

```
w=[60,65,66,70,68,72,64,70]
diff(w)
ans = 1×7    
     5     1     4    -2     4    -8     6
diff(w,2)
ans = 1×6    
    -4     3    -6     6   -12    14
diff(w,3)
ans = 1×5    
     7    -9    12   -18    26
```

第一个元素的一阶差分不存在，因为它没有上一个元素，不要把它上一个元素当0啊
不存在就是不存在

**diff(A,n,dim)**
当A是矩阵时，n代表n阶差分，dim代表维度
dim=1还是老样子沿着行方向对每一列计算  dim默认是1

n必须是正整数标量，dim必须是索引范围内的正整数标量
diff不支持使用 omitnan 来忽略 NaN

#### mean

计算平均值
**mean(A)** 向量A的平均值
**mean(A,dim)**A是矩阵，按维度算平均值,dim默认是1，dim等于1时可以不写
支持加入 omitnan 来忽略NaN

#### median

求中位数，又称中值
先对数据升序排序，然后去中间位置的值
**median(A)** 向量A的中位数
**median(A,dim)**A是矩阵，按维度算中位数,dim默认是1，dim等于1时可以不写
支持加入 omitnan 来忽略NaN



#### mode

计算众数，数据中出现次数最多的数,可以有多个
**mode(A)**
返回A中出现次数最多的值，如果有多个值，那么返回其中最小的一个，一个返回值
**mode(A,dim)**
A是矩阵，沿着dim方向算，dim默认1，可以不写

**计算众数时会自动忽略NaN**，不能再添加 omitnan 否则报错

**mode有两个返回值的例子**

**[M,F]=mode(A)**
M接收mode返回的那一个众数，而F接收该众数出现的次数

**三个返回值**

**[M,F,C]=mode(A)**
我们想让同样次数的众数一起返回，而不是只返回最小的那个，用这个
M是最小的众数，F是出现的次数
C是一个元胞数组，里面有一个由所有众数构成的列向量，包括M
元胞数组是由大括号括起来的数组，里面可以包含不同类型的元素

```
A = 1×13    
     1     1     2     2     3     3     4     5     6     7     8     9     0
m =  1
f =  2
c =  {3×1 double}
```

得到元胞数组是一个3x1的列向量，元胞数组里只有一个元素，也就是列向量
怎么提取元胞数组里的元素呢？ c{1}提取，c{2}就会报错，因为该数组里只有一个元素

同样可以加入参数dim指定维度

#### var

计算方差variance
方差分为总体方差和样本方差
总体方差的分母是数据个数n，而样本方差的分母是样本个数n-1
区别在于分母是否要减去一，所以总体方差会小一点

**var(A,w)**

w=0时，代表样本方差
w=1时，代表总体方差
w默认为0，可以不写

var(A,w) 向量计算方差
var(A,w,dim)矩阵计算方差
存在NaN时利用 omitnan 来忽略 NaN

注意var第二个参数不是维度，写上第二个参数那必定代表方差类型
第三个参数才能代表维度

#### std

标准差，方差开平方就是标准差，但是计算时直接用std函数啊
也分为总体标准差和样本标准差

std函数跟var函数用法完全相同
**std(A,w,dim)**
omitnan

#### min,max

1. **min(A,B)**
   求两个矩阵对应位置的最小值，返回同型矩阵
   每个位置上都是两个矩阵相同位置的min 

   ```
   A = 3×3    
        7     7     5
        6     9     9
       10     5     1
   B = 3×3    
        2     9     4
        2     9     6
        4     1     5
   min(A,B)
   ans = 3×3    
        2     7     4
        2     9     6
        4     1     1
   ```

   A,B大小可以不一样，只要A,B兼容，后面学
   比如B是个标量，那么A的每一个位置都跟这个数比，取最小值

   ```
   B=5
   min(A,B)
   ans = 3×3    
        5     5     5
        5     5     5
        5     5     1
   ```

   B是个行向量，那么矩阵column列跟B的column个元素比较
   第一列跟向量中的第一个数比，当然这样前提是B的元素个数等于A矩阵的列数
   B也可以是个列向量，那么是 矩阵的行跟B的行比较

   ```
   B=[4,5,6]
   min(A,B)
   ans = 3×3    
        4     5     5
        4     5     6
        4     5     1
   ```

   
